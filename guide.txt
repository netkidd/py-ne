###########
    GIT
###########

# There are two ways to work with GIT. Or we create a local repository in our local machine or we create a remote repository in github and then we clone it.


### Option 1 ###

# Set your Git name and Git email address. These are included in commits.
# You only have to do this once per system
git config --global user.name "Jimmy Joe"
git config --global user.email "jj@email.com"

# Make your repository directory
mkdir py-ne
cd py-ne

# Initialize the repository
git init

# Add a file
touch README.md
git add README.md
git commit -m 'Initial commit'

# Add a git remote (pointing to GitHub)
# Only necessary if you are going to push changes up to GitHub
# You will still need to create the remote 'working_dir' repository in GitHub
git remote add origin https://github.com/netkidd/py-ne.git



### Option 2 ###

# To clone a repository fron github to the local machine
git clone https://github.com/netkidd/py-ne




# Git automatically creates an hidden directory .git
# It keeps track of all the objects in the system. Commits are stored in the objects subdirectory


# In Git there is the concept of branch. We have a master branch that identifies the main project. At any time if we want to make some experimental changes we can create a new branch.
# All the changes done on the new branch project will not be seen in the main project. If we are satisfied with the changes they can be merged with the master project

# To show the branches we have and on which we are currently working on
git branch


# Git allows to have a kind of backup and restore system
# Every time we make a new commit Git makes a copy of the file storing a compressed version of it. Each commit is identified by a hash

# To add a file to git repository
git add test_file.txt

# Create a commit with a message (comment)
git commit -m "Adding test file"


# We can check what Git created in the .git/objects directory
cd .git/objects

find . -type f



# To check if there was any new change in the project that was not yet committed
git status

# To see all the activities done since the beginning of the project
git log


# If we make any additional change the procedure is always the same. Add and commit
git add test_file.txt
git commit -m "Adding a new line to test file"


# We can commit single files or entire directories (all the files inside will be committed)
# Each new file is store in .git directory. Any time is possible to retrieve any old version
# The directory we are working on changes. It points to the last commit by default. If we change branch it points to the last commit on that branch


# To push the changes to github (from local master branch to remote master branch). In this case only the branch source is specified (master), the branch destination by default is the same as the source
git push origin master

# In the previous command "origin" is actually an alias for the remote system (github). To show the origin alias
git remote -v


# To change user and email (git config file)
git config --global --edit

# If previous commits were done with wrong identity it's better to fix it for consistency. If there was no identity change the command is not necessary
git commit --amend --reset-author


# To pull changes from github (synchronize from github to local machine)
git pull origin master

# A Git pull always does a merge. A 'git pull' is a combination of two separate actions a 'git fetch' and a 'git merge'.
# Some situations prompt you to comment on the merge or require you to manually resolve the merge; other merges can just be handled automatically by Git.



# To create a new branch
git branch experiment_1

# To verify the new branch has been created
git branch


# To work in a different branch
git checkout experiment_1


# We can do commits and push the branch as we did with the master

# If at some point we want to merge the experiment_1 branch into the master branch

1) move to master branch
git checkout master

2) Merge
git merge experiment_1


# It's possible to fork somebody else repository in github. This way we get all their code copied in our github repository and we can make changes




############
    YAML
############


# We can use yaml on python scripts by importing yaml
import yaml


# YAML  is extensively used in Ansible


# We can use a test list to see the conversion between python notation and YAML
test_list = [[0,1,2,3], 'whatever', 'hello', {'ip_addr':'10.10.10.10', 'attribs': [0,1,2,3,4]}]


# To convert the test_list into YAML format we can use
yaml.dump(test_list, default_flow_style=True)


# YAML has also a more human readable format
print(yaml.dump(test_list, default_flow_style=False))


# We can also save it into a file
with open("yaml_file_example.yml", "w") as f:
  f.write(yaml.dump(test_list, default_flow_style=False))


# By default python does not add the first 3 hyphens but each YAML file should have them


# Here is an example

---

- - 0
  - 1
  - 2
  - 3
- whatever
- hello
- attribs:
  - 0
  - 1
  - 2
  - 3
  - 4
  ip_addr: 10.10.10.10
  version: 15


# Each hyphen represent a list item. Strings are not quoted. Dictionaries are like in python, Key-Value pairs



# To load a YAML file in python
with open("yaml_file_example.yml") as f:
  new_list = yaml.load(f)




############
    JSON
############


# Import json library
import json


# Sample list
test_list = [[0,1,2,3], 'whatever', 'hello', {'ip_addr':'10.10.10.10', 'attribs': [0,1,2,3,4]}]


# To convert the list in Json notation (dumps stands for dump string)
json.dumps(test_list)


# The result is almost the same as the notation in python. Here below is a comparison

>>> test_list
[[0, 1, 2, 3], 'whatever', 'hello', {'ip_addr': '10.10.10.10', 'attribs': [0, 1, 2, 3, 4]}]
>>>
>>>
>>> json.dumps(test_list)
'[[0, 1, 2, 3], "whatever", "hello", {"ip_addr": "10.10.10.10", "attribs": [0, 1, 2, 3, 4]}]'


# If we want to write it in a file (we use dump and not dumps)
with open("json_file_example.json", "w") as f:
  json.dump(test_list, f)



# To read from a Json file
with open("json_file_example.json") as f:
  new_list = json.load(f)




#########################
    CISCOCONFPARSE
#########################

# The library helps to deal with the hierarchical nature of cisco config
# Install the library
sudo pip install ciscoconfparse


# Import a useful class
from ciscoconfparse import CiscoConfParse


# To load an existing config file (from the current directory)
cisco_cfg = CiscoConfParse("cisco_show_run_example")


# Let's say we want to find all the lines that begin with "interface" (the result will be a list even if there will be a single element found)
interfaces = cisco_cfg.find_objects(r"^interface")


# We can go through the list and print each element
for i in interfaces:
  print(i.text)


# We can pull out each element in go deeper
fa4 = interfaces[4]

fa4.children

for child in fa4.children:
  print(child.text)


# In cisco config there can be multiple levels of indentation
# By using .childred it returns only the lines that are one level down
# Use .children again to go deeper

# If you want all the children, no matter the indentation use .all_children
fa4.all_children


# We can run some tests over each object
fa4.is_child

fa4.is_parent


# If you have a child you can find the parent or all the parents (multiple levels up)
child.parent

child.all_parents


# We can also make more complicated queries
# For example let's pick all interfaces that have "no ip address as child"
no_ip_int = cisco_cfg.find_objects_w_child(parentspec=r"^interface", childspec=r"no ip address")

for int in no_ip_int:
  print(int.text)


# The same way we can find all the parents that don't have a specified child (the only thing that changes in the command is "wo")
int_with_ip = cisco_cfg.find_objects_wo_child(parentspec=r"^interface", childspec=r"no ip address")

for int in int_with_ip:
  print(int)

# The library works with everything that has an indented structure, not only for a show run.
# For example we can use it to investigate some other show commands (e.g. sh interfaces)



#########################
    TELNETLIB
#########################

# Here is a quick example of how to establish a telnet connection via a Simple Python script
# In this case we're not doing anything, just opening and closing the connection.

***********
#/usr/bin/env python
import telnetlib

TELNET_PORT = 23
TELNET_TIMEOUT = 6

def main():
    ip_addr = '50.76.53.27'
    username = 'pyclass'
    password = '88newclass'

    remote_conn = telnetlib.Telnet(ip_addr, TELNET_PORT, TELNET_TIMEOUT)
    remote_conn.close()

if __name__ == "__main__":
    main()

************


# If we want to read from the telnet connection we can use some read method
# In this example we read until "sername" is found or until the timeout has expired (6)
output = remote_conn.read_until("sername", TELNET_TIMEOUT)


# read_very_eager reads all the data that is available in a non blocking way
# Before using that it's a good idea to introduce some pause to allow the processing before reading the output
# For example 1 sec is enough
import time
time.sleep(1)
output = remote_conn.read_very_eager()


# If we want to send commands or any data on the channel we can use the write method
# Remember always to add '\n', it's like pressing Enter after sending a command
remote_conn.write(username + '\n')

# Before lunching show commands it's a good idea to disable paging in order to
# display the entire output
remote_conn.write("terminal length 0" + '\n')
remote_conn.write("show version" + '\n')


# A well designed script is modular and avoids repetitions
# We can use functions and classes

# Take as parameters the telnet connection and the command to send
# Execute the command and return the output
def send_command(remote_conn, cmd):
    cmd = cmd.strip()
    remote_conn.write(cmd + '\n')
    time.sleep(1)
    output = remote_conn.read_very_eager()
    return output


# Take as parameters username, password, connection timeout
# Login and returns the output until the login process
def login(remote_conn, username, password, TELNET_TIMEOUT):
    output = remote_conn.read_until("sername:", TELNET_TIMEOUT)
    remote_conn.write(username + '\n')
    output += remote_conn.read_until("assword:", TELNET_TIMEOUT)
    remote_conn.write(password + '\n')
    return output

# To improve above login function it's a good idea to try 2-3 times if the login fails


# In general when trying to connect to a device something can go wrong
# For example the connection can timeout and if we don't handle the exception a traceback error is displayed
# So we can wrap the connection inside a try - except block
# When there is a timeout the exception raised is "socket.timeout" . We can see that by running the script and checking the traceback
# sys.exit returns a non zero exit status (to indicate an error) and a nice message to the user

import socket
import sys

def telnet_connection(ip_addr, TELNET_PORT, TELNET_TIMEOUT):
    try:
        remote_conn = telnetlib.Telnet(ip_addr, TELNET_PORT, TELNET_TIMEOUT)
        return remote_conn
    except socket.timeout:
        sys.exit("Connection timed-out")

# If you're trying to connect to 100 devices and one fails you don't want your script to exit completely but you just want to pass to the next loop iteration
# Be careful on how you handle the exceptions


# When you notice that several functions need the same parameters (like remote_conn or timeout in this case)
# it's a good indicator that you should write a class




####################
 SNMP INTRO
####################

# SNMP is really good if you're trying to gather info from a device.
# It's not so good to change the device config, we have better ways to do it

# There are 3 version, only v3 has ecryption


# OID = Object identifier. It's a string of numbers separated by a period
# OID tree is hierarchically organized
# Every piece of data in a device is identified by an OID
# We can gather data from a device by specifying the OID we're interested in
# If the value is scalar (e.g. interface errors, cpu usage, etc. - it's a single value) we have to append .0 to the OID
# If it's tabular data you have to append a number for each row of the table (e.g. output rate for all interfaces)


# MIB = Management Information base_list
# It provides a definition of the data, it assigns variables to OIDs


# Libraries available pysnmp (pure python library), netsmnp (C library)

# We can use netsnmp utilities to quickly check snmp gets and snmp walk from the linux command lines




##############################
 INSTALLING PYTHON LIBRARIES
##############################


# Classical method

1) Download the zipped archive
wget https://pypi.python.org/packages/source/p/pysnmp/pysnmp-4.2.5.tar.gz

2) Unzip the archive. The output will be a tarball
gunzip pysnmp-4.2.5.tar.gz

3) Extract the data from the archive (tarball). The p flag is used to preserve the permissions (to check)
tar -xpf pysnmp-4.2.5.tar

4) Move into the newly uncompressed directory and run the setup to install the library
cd pysnmp-4.2.5
python setup.py install



# New method with PIP. It's the preferred method to install python libraries because
# it also handles very well the library dependencies
pip install pysnmp==4.2.5

# If you don't specify the version, the last one available will be used by default




##################
 SNMP Example
##################


# To find an OID to query we can use Cisco OID browser
http://snmp.cloudapps.cisco.com/Support/SNMP/do/BrowseOID.do


# The MIB-2 is a standard MIB that all snmp devices support
# It starts at OID: 1.3.6.1.2.1  (iso.org.dod.internet.mgmt.mib-2)



# We can use the snmp tools from Linux command line for testing
# For example let's pick the system description (like show version)
# The system description is OID:1.3.6.1.2.1.1.1
# Since it's a scalar value we have to append 0 (for tabular data we would specify a number equal to the row  we want to query)
snmpget -v 2c -c galileo 10.2.52.32 1.3.6.1.2.1.1.1.0


# We can do an SNMP walk to go through the OID tree to find all the objects below
# the specified point in the hierarchy
# For example let's query everything that is below the system level (OID: 1.3.6.1.2.1.1)
snmpwalk -Os -c galileo -v 2c 10.2.52.32 1.3.6.1.2.1.1



# We can do the same with Python. We use two helper functions to simplify the procedure

# Copy the snmp_helper library in the local directory, then import the functions
from snmp_helper import snmp_get_oid, snmp_extract

COMUNITY_STRING = 'galileo'
SNMP_PORT = 161
IP = '10.2.52.32'

# A Tuple to identify the target
a_device = (IP, COMUNITY_STRING, SNMP_PORT)

# Look for system description
OID = '1.3.6.1.2.1.1.1.0'

# Query the device. The results is in hexadecimal
snmp_data = snmp_get_oid(a_device, oid=OID)

# Transform the data in human readable form
output = snmp_extract(snmp_data)

print output



#####################
 PYTHON LIBRARY PATH
#####################


# To see where python looks for libraries we can inspect sys.path
import sys
from pprint import pprint
pprint(sys.path)

# Result:
['',
 '/usr/lib64/python27.zip',
 '/usr/lib64/python2.7',
 '/usr/lib64/python2.7/plat-linux2',
 '/usr/lib64/python2.7/lib-tk',
 '/usr/lib64/python2.7/lib-old',
 '/usr/lib64/python2.7/lib-dynload',
 '/usr/lib64/python2.7/site-packages',
 '/usr/lib/python2.7/site-packages']


# By default it checks in the current directory and some other places


# If we want to add a library and we want to be accessible from anywhere in the system (not only from current directory)
# there are two main ways

# Option 1) Add the path to new library in the PYTHONPATH environment variable (Not set by default). Use "env | grep PYTHON" to verify
export PYTHONPATH='/home/me/My_library_directory'

# Option 2) Move the library in /usr/lib/python2.7/site-packages (that is already in the python path)
mv file.py /usr/lib/python2.7/site-packages


# We should always keep in mind that is a best practice to write reusable code
# meaning some pieces of code might be useful in other scripts and we don't need to re-write them
# We can basically create our own libraries. Each script we create can as used as a library for another script
